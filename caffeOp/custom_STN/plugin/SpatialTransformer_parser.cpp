/*
* Copyright (c) Huawei Technologies Co., Ltd. 2017-2018. All rights reserved.
* Description: generated by MindSporeStudio
* Author: Huawei
* Create: 2017-06-06
 */
#include <Python.h>
#include "custom/custom_op.h"
#include "framework/omg/register.h"
#include "framework/omg/omg_types.h"
#include "proto/caffe/caffe.pb.h"
#include "operator.h"
#include "attr_value.h"
#include <memory>
#include <string>
#include <vector>
using namespace ge;
namespace domi {

const int DOMI_COMMON_ONE = 1;
const int DOMI_COMMON_TWO = 2;
const int DOMI_COMMON_THREE = 3;

// Parse the parameters from caffe model, and pass them to the inner model.
Status CaffeSpatialTransformerParseParams(const Message *op_origin, ge::Operator &op_dest)
{
    const caffe::LayerParameter *layer = dynamic_cast<const caffe::LayerParameter *>(op_origin);

    // Ckeck operator parameter's validity
    if (nullptr == layer) {
        printf("Dynamic cast op_src to LayerParameter failed\n");
        return FAILED;
    }
    const caffe::SpatialTransformerParameter &param = layer->st_param();

    op_dest.SetAttr("output_h", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.output_h()));
    op_dest.SetAttr("output_w", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.output_w()));
    return SUCCESS;
}

// Function to acquire output tensor descriptor
Status CaffeSpatialTransformerInferShapeAndType(const ge::Operator &op, vector<ge::TensorDesc> &v_output_desc)
{
    auto tensorDesc = op.GetInputDesc(0);
    auto shape = tensorDesc.GetShape();

    int64_t outputH = 0;
    ge::AttrValue outputHAttrValue;
    if ((ge::GRAPH_SUCCESS != op.GetAttr("output_h", outputHAttrValue)) ||
        (ge::GRAPH_SUCCESS != outputHAttrValue.GetValue<ge::AttrValue::INT>(outputH))) {
        printf("Get output_h failed!\n");
    }
    if (outputH == 0) {
        outputH = op.GetInputDesc(0).GetShape().GetDim(1);
    }

    int64_t outputW = 0;
    ge::AttrValue outputWAttrValue;
    if ((ge::GRAPH_SUCCESS != op.GetAttr("output_w", outputWAttrValue)) ||
        (ge::GRAPH_SUCCESS != outputWAttrValue.GetValue<ge::AttrValue::INT>(outputW))) {
        printf("Get output_w failed!\n");
    }
    if (outputW == 0) {
        outputW = op.GetInputDesc(0).GetShape().GetDim(DOMI_COMMON_TWO);
    }

    shape.SetDim(0, op.GetInputDesc(0).GetShape().GetDim(0));  // NHWC format
    shape.SetDim(DOMI_COMMON_ONE, outputH);
    shape.SetDim(DOMI_COMMON_TWO, outputW);
    shape.SetDim(DOMI_COMMON_THREE, op.GetInputDesc(0).GetShape().GetDim(DOMI_COMMON_THREE));

    tensorDesc.SetShape(shape);
    v_output_desc.push_back(tensorDesc);

    return SUCCESS;
}

// Pass the parameters you just parsed from the parseParam() to the op python function
Status CaffeSpatialTransformerBuildTeBin(const ge::Operator &op, TEBinInfo &te_bin_info)
{
    Py_Initialize();

    // Parse input tensor descriptor
    ge::TensorDesc inputDesc = op.GetInputDesc(0);
    auto shape = inputDesc.GetShape();

    // Parse operator's parameter and attach exception catching
    int64_t outputH = 0;
    ge::AttrValue outputHAttrValue;
    if ((ge::GRAPH_SUCCESS != op.GetAttr("output_h", outputHAttrValue))
        || (ge::GRAPH_SUCCESS != outputHAttrValue.GetValue<ge::AttrValue::INT>(outputH))) {
        printf("GetOpAttr outputH  failed!\n");
    }
    if (outputH == 0) {
        outputH = inputDesc.GetShape().GetDim(1);
    }

    int64_t outputW = 0;
    ge::AttrValue outputWAttrValue;
    if ((ge::GRAPH_SUCCESS != op.GetAttr("output_w", outputWAttrValue))
        || (ge::GRAPH_SUCCESS != outputWAttrValue.GetValue<ge::AttrValue::INT>(outputW))) {
        printf("GetOpAttr output_w  failed!\n");
    }
    if (outputW == 0) {
        outputW = inputDesc.GetShape().GetDim(DOMI_COMMON_TWO);
    }

    // Parse input shape, validate if it is equal to 4
    if (inputDesc.GetShape().GetDimNum() != 4) {
        printf("The shape size is %d, which is not 4!", (int32_t)inputDesc.GetShape().GetDimNum());
        return FAILED;
    }

    std::string filePath = "../operator/SpatialTransformer";
    std::string funcName = "SpatialTransformer";
    std::string kernelName = "SpatialTransformer_" + std::to_string(inputDesc.GetShape().GetDim(0)) 
                             + "_" + std::to_string(inputDesc.GetShape().GetDim(DOMI_COMMON_ONE)) 
                             + "_" + std::to_string(inputDesc.GetShape().GetDim(DOMI_COMMON_TWO)) 
                             + "_" + std::to_string(inputDesc.GetShape().GetDim(DOMI_COMMON_THREE));

    // get real path of Py module
    char *cwd = getcwd(NULL, 0);
    if (cwd == NULL) {
        printf("Get current directory path failed!\n");
        return FAILED;
    }
    std::string cwdS(cwd);
    char *realPath = realpath((cwdS + "/" + filePath + ".py").c_str(), NULL);
    if (realPath == NULL) {
        printf("Get real path of Py module failed!\n");
        return FAILED;
    }
    std::string realFilePathString = std::string(realPath);
    std::string realFilePath = realFilePathString.substr(0, realFilePathString.rfind("."));

    /* TODO: Pass the parameters to the api function */
    te::BuildTeCustomOp(te_bin_info.ddk_version, op.GetName(), realFilePath, funcName,
                        "(i,i,i,i), (i,i), s, s",
                        inputDesc.GetShape().GetDim(0), inputDesc.GetShape().GetDim(DOMI_COMMON_ONE),
                        inputDesc.GetShape().GetDim(DOMI_COMMON_TWO), inputDesc.GetShape().GetDim(DOMI_COMMON_THREE),
                        outputH, outputW,
                        "float16",
                        kernelName.c_str());

    /* TODO: Set the path of the generation files */
    te_bin_info.bin_file_path = "./kernel_meta/" + kernelName + ".o";
    te_bin_info.json_file_path = "./kernel_meta/" + kernelName + ".json";
    Py_Finalize();
    return SUCCESS;
}

/**
    * Register the op plugin
    * REGISTER_CUSTOM_OP:    Operator type name in om model, can be any but not duplicate with existence. case sensitive
    * FrameworkType:       Enum type, only support CAFFE
    * OriginOpType:        name of the operator type name in CAFFE
    * ParseParamsFn:      Op parameters parse function
    * InferShapeAndTypeFn: Set output description and datatype function
    * TEBinBuildFn:    Class name of op parser
    * ImplyType:           Instantiation type, TVM
 */
REGISTER_CUSTOM_OP("SpatialTransformer")
.FrameworkType(CAFFE)
.OriginOpType("SpatialTransformer")
.ParseParamsFn(CaffeSpatialTransformerParseParams)
.InferShapeAndTypeFn(CaffeSpatialTransformerInferShapeAndType)
.TEBinBuildFn(CaffeSpatialTransformerBuildTeBin)
.ImplyType(ImplyType::TVM);
}  // namespace domi


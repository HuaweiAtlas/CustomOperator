"""
generated by MindSpore studio

"""

from te import tvm
from te.platform.cce_build import build_config
from topi.cce import util

SHAPE_SIZE_LIMIT = 100000000  # shape limit for darknet_upsample


@util.check_input_type((list, tuple), str, int, str, str, bool, bool)
def custom_Upsample(shape, dtype, scale, data_format="channels_last",
                    kernel_name="cce_darknet_upsample", need_build=False,
                    need_print=False):
    """
    Parameters
    ----------
    shape: input tensor's shape

    dtype: input tensor's dtype, support:`float16,float32

    scale: the upsampling factors

    data_format: "channels_last" or "channels_first"

    kernel_name : kernel name, default value is "MyUpsample"

    need_buid : if need to build CCEC kernel, default value is False

    need_print : if need to print the ir, default value is False

    Returns
    -------
    None
    """

    """
    TODO:
    Please refer to the TE DSL Manual, And code here with TE DSL.
    """
    inp_dtype = dtype.lower()
    check_list = ["float16", "float32", "int32", "int8", "uint8"]
    if inp_dtype not in check_list:
        raise RuntimeError(
            "upsample only support %s while dtype is %s" % (
                ",".join(check_list), dtype))

    util.check_kernel_name(kernel_name)
    util.check_shape_rule(shape)
    util.check_shape_size(shape, SHAPE_SIZE_LIMIT)
    size = (scale, scale)

    shape_size = len(shape)
    if not (shape_size == 4 or shape_size == 5):
        raise RuntimeError(
            "upsample only support 4D or 5D while len(shape):%d" % len(shape))

    input_tensor = tvm.placeholder(shape, name="input_tensor", dtype=inp_dtype)

    res = None
    if shape_size == 5:
        # shape_size == 5 D-sepecial (N, C1, H, W, C0)
        output_shape = (
            shape[0], shape[1], shape[2] * size[0], shape[3] * size[1],
            shape[4])
        res = tvm.compute(output_shape,
                          lambda n, c0, h, w, c: input_tensor[
                              n, c0, h // size[0], w // size[1], c])
    else:
        if data_format == "channels_last":
            output_shape = (
                shape[0], shape[1] * size[0], shape[2] * size[1], shape[3])
            res = tvm.compute(output_shape,
                              lambda n, h, w, c: input_tensor[
                                  n, h // size[0], w // size[1], c])
        elif data_format == "channels_first":
            output_shape = (
                shape[0], shape[1], shape[2] * size[0], shape[3] * size[1])
            res = tvm.compute(output_shape,
                              lambda n, c, h, w: input_tensor[
                                  n, c, h // size[0], w // size[1]])
        else:
            raise RuntimeError(
                "upsample only support channels_last|channels_first "
                "while input type %s" % data_format)

    schedule = tvm.create_schedule(res.op)
    if need_print:
        with build_config:
            print(tvm.lower(schedule, [input_tensor, res], simple_mode=True))

    if need_build:
        with build_config:
            tvm.build(schedule, [input_tensor, res], "cce", name=kernel_name)

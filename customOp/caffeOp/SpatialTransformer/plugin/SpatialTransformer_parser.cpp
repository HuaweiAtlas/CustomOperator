/*
* Copyright (c) Huawei Technologies Co., Ltd. 2017-2018. All rights reserved.
* Description: generated by MindSporeStudio
* Author: Huawei
* Create: 2017-06-06
*/
#include "custom/custom_op.h"
#include "framework/omg/register.h"
#include "framework/omg/omg_types.h"
#include "proto/caffe/caffe.pb.h"
#include "operator.h"
#include "attr_value.h"
#include <memory>
#include <string>
#include <vector>

namespace domi
{
    // Parse the parameters from caffe model, and pass them to the inner model.
    Status CaffeSpatialTransformerParseParams(const Message* op_origin, ge::Operator& op_dest)
    {
        const caffe::LayerParameter* layer = dynamic_cast<const caffe::LayerParameter*>(op_origin);

        // Ckeck operator parameter's validity
        
        if (nullptr == layer)
        {
            printf("Dynamic cast op_src to LayerParameter failed\n");
            return FAILED;
        }
        const caffe::SpatialTransformerParameter& param = layer->st_param();
        
        op_dest.SetAttr("output_h", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.output_h()));
        op_dest.SetAttr("output_w", ge::AttrValue::CreateFrom<ge::AttrValue::INT>(param.output_w()));
        return SUCCESS;
    }

    // Function to acquire output tensor descriptor
    Status CaffeSpatialTransformerInferShapeAndType(const ge::Operator& op, vector<ge::TensorDesc>& v_output_desc)
    {
    	auto tensorDesc      = op.GetInputDesc(0);
    	auto shape = tensorDesc.GetShape();
    	
    	int64_t output_h = 0;
        ge::AttrValue output_hAttrValue;        
        if ((ge::GRAPH_SUCCESS != op.GetAttr("output_h", output_hAttrValue)) || (ge::GRAPH_SUCCESS != output_hAttrValue.GetValue<ge::AttrValue::INT>(output_h)))
        {
            printf("Get output_h failed!\n");
        }
        if(output_h == 0)
            output_h = op.GetInputDesc(0).GetShape().GetDim(1);
        
        int64_t output_w = 0;
        ge::AttrValue output_wAttrValue;        
        if ((ge::GRAPH_SUCCESS != op.GetAttr("output_w", output_wAttrValue)) || (ge::GRAPH_SUCCESS != output_wAttrValue.GetValue<ge::AttrValue::INT>(output_w)))
        {
            printf("Get output_w failed!\n");
        }
        if(output_w == 0)
            output_w = op.GetInputDesc(0).GetShape().GetDim(2);
        
        shape.SetDim(0, op.GetInputDesc(0).GetShape().GetDim(0)); // NHWC format
        shape.SetDim(1, output_h);
        shape.SetDim(2, output_w);
        shape.SetDim(3, op.GetInputDesc(0).GetShape().GetDim(3));
        
        tensorDesc.SetShape(shape);
        v_output_desc.push_back(tensorDesc);

        return SUCCESS;
    }

    // Pass the parameters you just parsed from the parseParam() to the op python function
    Status CaffeSpatialTransformerBuildTeBin(const ge::Operator& op, TEBinInfo& te_bin_info)
    {
        std::string FilePath   = "";
        std::string FuncName   = "";
        std::string KernelName = "";

         // Parse input tensor descriptor
        ge::TensorDesc input_desc = op.GetInputDesc(0);
        auto shape = input_desc.GetShape();
        
        // Parse operator's parameter and attach exception catching
        int64_t output_h = 0;
        ge::AttrValue output_hAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("output_h", output_hAttrValue)) 
            || (ge::GRAPH_SUCCESS != output_hAttrValue.GetValue<ge::AttrValue::INT>(output_h)))
        {
            printf("GetOpAttr output_h  failed!\n");
        }
        if(output_h == 0)
            output_h = input_desc.GetShape().GetDim(1);
        
        int64_t output_w = 0;
        ge::AttrValue output_wAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("output_w", output_wAttrValue)) 
            || (ge::GRAPH_SUCCESS != output_wAttrValue.GetValue<ge::AttrValue::INT>(output_w)))
        {
            printf("GetOpAttr output_w  failed!\n");
        }
        if(output_w == 0)
            output_w = input_desc.GetShape().GetDim(2);

        // Parse input shape, validate if it is equal to 4
        if (input_desc.GetShape().GetDimNum() != 4)
        {
            printf("The shape size is %d, which is not 4!", (int32_t)input_desc.GetShape().GetDimNum());
            return FAILED;
        }

        FilePath   = "/home/mindstudio/tools/projects/SpatialTransformer/SpatialTransformer/operator/SpatialTransformer";
        FuncName   = "SpatialTransformer";
        KernelName = "SpatialTransformer" + std::to_string(shape.GetDim(0)) + "_" + std::to_string(shape.GetDim(1)) + "_"  
                                          + std::to_string(shape.GetDim(2)) + "_" + std::to_string(shape.GetDim(3));
        

        /* TODO: Pass the parameters to the api function */
        te::BuildTeCustomOp(te_bin_info.ddk_version, op.GetName(), FilePath, FuncName,
                "(i,i,i,i), (i,i), s, s",
                input_desc.GetShape().GetDim(0), input_desc.GetShape().GetDim(1),
                input_desc.GetShape().GetDim(2), input_desc.GetShape().GetDim(3),
                output_h, output_w,
                "float32", 
                KernelName.c_str());

        /* TODO: Set the path of the generation files */
        te_bin_info.bin_file_path = "./kernel_meta/" + KernelName + ".o";
        te_bin_info.json_file_path = "./kernel_meta/" + KernelName + ".json";

        return SUCCESS;
    }

     /**
    * Register the op plugin
    * REGISTER_CUSTOM_OP:    Operator type name in om model, can be any but not duplicate with existence. case sensitive
    * FrameworkType:       Enum type, only support CAFFE
    * OriginOpType:        name of the operator type name in CAFFE
    * ParseParamsFn:      Op parameters parse function
    * InferShapeAndTypeFn: Set output description and datatype function
    * TEBinBuildFn:    Class name of op parser
    * ImplyType:           Instantiation type, TVM
    */
    REGISTER_CUSTOM_OP("SpatialTransformer")
        .FrameworkType(CAFFE)
        .OriginOpType("SpatialTransformer")
        .ParseParamsFn(CaffeSpatialTransformerParseParams)
        .InferShapeAndTypeFn(CaffeSpatialTransformerInferShapeAndType)
        .TEBinBuildFn(CaffeSpatialTransformerBuildTeBin)
        .ImplyType(ImplyType::TVM);
}

